% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibration_slope.R
\name{calibration_slope}
\alias{calibration_slope}
\alias{calibration_large}
\alias{c_statistic}
\alias{oe_ratio}
\alias{brier_score}
\title{Compute performance in terms of various typical calibration and discrimination measures.}
\usage{
calibration_slope(dd, fm)

calibration_large(dd, fm)

c_statistic(dd, fm)

oe_ratio(dd, fm)

brier_score(dd, fm)
}
\arguments{
\item{dd}{A dataset.}

\item{fm}{The formula that will be called by the model, of the form \code{outcome ~ score} (character).}
}
\value{
A single performance measure (numeric).
}
\description{
Here we provide several functions to compute some typical performance measures 
for calibration and discrimination. This is however not intended to be an 
exhaustive set of performance measures.
}
\details{
Please note that \code{\link{compute_performance}} will use \code{try}, and return \code{NA} if the function has an error. Of the potentially large number of cohort, score and bootstrap sample, this was a straightforward way to prevent \code{\link{compute_performance}} from returning an error for the whole dataset. However, if the function to compute performance generally does not work (for example, if the package \code{pROC} is required but not loaded), this behavior also prevents warning message for, say, unloaded R packages from being printed. See the example for how to redefine the provided functions with a transformation.
}
\section{Functions}{
\itemize{
\item \code{calibration_slope}: Estimate calibration slope

\item \code{calibration_large}: Estimate calibration-in-the-large

\item \code{c_statistic}: Estimate c-Statistics / Area under the ROC curve

\item \code{oe_ratio}: Estimate ratio of observed to expected number of events

\item \code{brier_score}: Estimate Brier score
}}

\examples{
n <- 100
x <- rnorm(n)
y <- as.numeric(rnorm(n, x) > 1)
dat <- data.frame(x, y)

# log calibration slope
log_cs <- function(dd, fm){
    log(calibration_slope(dd, fm))
}

calibration_slope(dat, "y ~ x")
log_cs(dat, "y ~ x")

}
